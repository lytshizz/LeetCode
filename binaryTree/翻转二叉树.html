<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>invert-binary-tree - 翻转二叉树</title>
  </head>
  <body></body>
  <script>
    /**
     * 翻转二叉树
     * 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

     * 示例 1：
     * 输入：root = [4,2,7,1,3,6,9]
     * 输出：[4,7,2,9,6,3,1]

     * 示例 2：
     * 输入：root = [2,1,3]
     * 输出：[2,3,1]

     * 示例 3：
     * 输入：root = []
     * 输出：[]
     */

    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */

    /**
     * 翻转二叉树
     * 思路一：递归思路，将左右子树互换位置，前序遍历
     * @param {TreeNode} root
     * @return {TreeNode}
     * https://leetcode.cn/problems/invert-binary-tree/
     * 执行用时：76 ms, 在所有 JavaScript 提交中击败了5.45%的用户
     * 内存消耗：41.5 MB, 在所有 JavaScript 提交中击败了33.66%的用户
     * https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/submissions/
     * 执行用时：56 ms, 在所有 JavaScript 提交中击败了88.18%的用户
     * 内存消耗：41.3 MB, 在所有 JavaScript 提交中击败了57.62%的用户
     */
    var invertTree = function (root) {
      if (root === null) return root;

      function traverse(root) {
        if (root === null) return;

        // 假设此二叉树是完美二叉树
        const leftNode = root.left;
        const rightNode = root.right;
        root.left = null;
        root.right = null;
        if (leftNode !== null) {
          root.right = leftNode;
        }
        if (rightNode !== null) {
          root.left = rightNode;
        }

        traverse(root.left);
        traverse(root.right);
      }

      traverse(root);
      return root;
    };
  </script>
</html>
